{"ast":null,"code":"var _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n/**\n * @author j_bleach 2018/8/18\n * @describe 媒体记录（包含开始，暂停，停止等媒体流及回调操作）\n * @param Target 被装饰类（AudioAnalyser）\n */\n\n\nimport convertWav from \"./audioConvertWav\";\nimport WebWorker from \"./mp3worker.js\";\n\nvar MediaRecorderFn = function MediaRecorderFn(Target) {\n  var constraints = {\n    audio: true\n  };\n  var mp3Worker = new Worker(WebWorker);\n  return function (_Target) {\n    _inherits(MediaRecorderClass, _Target);\n\n    function MediaRecorderClass(props) {\n      _classCallCheck(this, MediaRecorderClass);\n\n      var _this = _possibleConstructorReturn(this, (MediaRecorderClass.__proto__ || Object.getPrototypeOf(MediaRecorderClass)).call(this, props));\n\n      _this.startAudio = function () {\n        var recorder = _this.mediaRecorder;\n\n        if (!recorder || recorder && recorder.state === \"inactive\") {\n          navigator.mediaDevices.getUserMedia(constraints).then(function (stream) {\n            _this.recordAudio(stream);\n          }).catch(function (err) {\n            MediaRecorderClass.checkAndExecFn(_this.props.errorCallback, err); // throw new Error(\"getUserMedia failed:\", err);\n          });\n          return false;\n        }\n\n        if (recorder && recorder.state === \"paused\") {\n          _this.resumeAudio();\n        }\n      };\n\n      _this.pauseAudio = function () {\n        var recorder = _this.mediaRecorder;\n\n        if (recorder && recorder.state === \"recording\") {\n          recorder.pause();\n\n          recorder.onpause = function () {\n            MediaRecorderClass.checkAndExecFn(_this.props.pauseCallback);\n          };\n\n          _this.audioCtx.suspend();\n        }\n      };\n\n      _this.stopAudio = function () {\n        var _this$props = _this.props,\n            audioType = _this$props.audioType,\n            audioOptions = _this$props.audioOptions;\n        var recorder = _this.mediaRecorder;\n\n        if (recorder && [\"recording\", \"paused\"].includes(recorder.state)) {\n          recorder.stop();\n\n          recorder.onstop = function () {\n            _this.audioStream2Blob(audioType, audioOptions, _this.props.stopCallback);\n\n            _this.audioChunk = []; // 结束后，清空音频存储\n          };\n\n          _this.audioCtx.suspend();\n\n          _this.initCanvas();\n        }\n      };\n\n      MediaRecorderClass.compatibility();\n      _this.audioChunk = []; // 音频信息存储对象\n\n      _this.mediaRecorder = null; // 媒体记录对象\n\n      _this.audioCtx = new (window.AudioContext || window.webkitAudioContext)(); // 音频上下文\n\n      _this.analyser = _this.audioCtx.createAnalyser();\n      return _this;\n    }\n    /**\n     * @author j_bleach 2018/08/02 17:06\n     * @describe 浏览器navigator.mediaDevices兼容性处理\n     */\n\n\n    _createClass(MediaRecorderClass, [{\n      key: \"audioStream2Blob\",\n\n      /**\n       * @author j_bleach 2018/8/19\n       * @describe 音频流转blob对象\n       * @param type: string 音频的mime-type\n       * @param cb: function 录音停止回调\n       */\n      value: function audioStream2Blob(type, audioOptions, cb) {\n        var _this2 = this;\n\n        var wavBlob = null;\n        var chunk = this.audioChunk;\n\n        var audioWav = function audioWav() {\n          var fr = new FileReader();\n          fr.readAsArrayBuffer(new Blob(chunk, {\n            type: type\n          }));\n\n          var frOnload = function frOnload(e) {\n            var buffer = e.target.result;\n\n            _this2.audioCtx.decodeAudioData(buffer).then(function (data) {\n              wavBlob = new Blob([new DataView(convertWav(data, audioOptions))], {\n                type: \"audio/wav\"\n              });\n              MediaRecorderClass.checkAndExecFn(cb, wavBlob);\n            });\n          };\n\n          fr.onload = frOnload;\n        };\n\n        var audioMp3 = function audioMp3() {\n          var fr = new FileReader();\n          fr.readAsArrayBuffer(new Blob(chunk, {\n            type: \"audio/wav\"\n          }));\n\n          var frOnload = function frOnload(e) {\n            var buffer = e.target.result;\n\n            _this2.audioCtx.decodeAudioData(buffer).then(function (data) {\n              var wavBuf = convertWav(data, audioOptions);\n              mp3Worker.postMessage({\n                cmd: \"init\",\n                config: {\n                  bitRate: 128\n                }\n              });\n              mp3Worker.postMessage({\n                cmd: \"encode\",\n                rawInput: wavBuf\n              });\n              mp3Worker.postMessage({\n                cmd: \"finish\"\n              });\n\n              mp3Worker.onmessage = function (e) {\n                if (e.data.cmd == \"end\") {\n                  var mp3Blob = new Blob(e.data.buf, {\n                    type: type\n                  });\n                  MediaRecorderClass.checkAndExecFn(cb, mp3Blob);\n                }\n              };\n            });\n          };\n\n          fr.onload = frOnload;\n        };\n\n        switch (type) {\n          case \"audio/webm\":\n          case \"audio/mp4\":\n            MediaRecorderClass.checkAndExecFn(cb, new Blob(chunk, {\n              type: MediaRecorderClass.mediaSupported()\n            }));\n            break;\n\n          case \"audio/wav\":\n            audioWav();\n            break;\n\n          case \"audio/mp3\":\n            audioMp3();\n            break;\n\n          default:\n            return void 0;\n        }\n      }\n      /**\n       * @author j_bleach 2018/8/18\n       * @describe 开始录音\n       */\n\n      /**\n       * @author j_bleach 2018/8/19\n       * @describe 暂停录音\n       */\n\n      /**\n       * @author j_bleach 2018/8/18\n       * @describe 停止录音\n       */\n\n    }, {\n      key: \"recordAudio\",\n\n      /**\n       * @author j_bleach 2018/8/18\n       * @describe mediaRecorder音频记录\n       * @param stream: binary data 音频流\n       */\n      value: function recordAudio(stream) {\n        var _this3 = this;\n\n        var _props = this.props,\n            audioBitsPerSecond = _props.audioBitsPerSecond,\n            timeslice = _props.timeslice;\n        var mimeType = MediaRecorderClass.mediaSupported();\n        this.mediaRecorder = new MediaRecorder(stream, {\n          audioBitsPerSecond: audioBitsPerSecond,\n          mimeType: mimeType\n        });\n\n        this.mediaRecorder.ondataavailable = function (event) {\n          MediaRecorderClass.checkAndExecFn(_this3.props.onRecordCallback, event.data);\n\n          _this3.audioChunk.push(event.data);\n        };\n\n        this.audioCtx.resume();\n        this.mediaRecorder.start(timeslice);\n\n        this.mediaRecorder.onstart = function (e) {\n          MediaRecorderClass.checkAndExecFn(_this3.props.startCallback, e);\n        };\n\n        this.mediaRecorder.onresume = function (e) {\n          _this3.initAudioAnalyser(stream);\n\n          MediaRecorderClass.checkAndExecFn(_this3.props.startCallback, e);\n        };\n\n        this.mediaRecorder.onerror = function (e) {\n          MediaRecorderClass.checkAndExecFn(_this3.props.errorCallback, e);\n        };\n\n        this.initAudioAnalyser(stream);\n        this.renderCurve();\n      }\n      /**\n       * @author j_bleach 2019/10/31\n       * @describe 重置音频上下文（解决谷歌浏览器 音频数组链接断开问题）\n       */\n\n    }, {\n      key: \"initAudioAnalyser\",\n      value: function initAudioAnalyser(stream) {\n        this.analyser = this.audioCtx.createAnalyser();\n        var source = this.audioCtx.createMediaStreamSource(stream);\n        source.connect(this.analyser);\n      }\n      /**\n       * @author j_bleach 2018/8/19\n       * @describe 恢复录音\n       */\n\n    }, {\n      key: \"resumeAudio\",\n      value: function resumeAudio() {\n        this.audioCtx.resume();\n        this.mediaRecorder.resume();\n      }\n    }], [{\n      key: \"compatibility\",\n      value: function compatibility() {\n        var _this4 = this;\n\n        var promisifiedOldGUM = function promisifiedOldGUM(constraints) {\n          // First get ahold of getUserMedia, if present\n          var getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia; // Some browsers just don't implement it - return a rejected promise with an error\n          // to keep a consistent interface\n\n          if (!getUserMedia) {\n            MediaRecorderClass.checkAndExecFn(_this4.props ? _this4.props.errorCallback : null);\n            return Promise.reject(new Error(\"getUserMedia is not implemented in this browser\"));\n          } // Otherwise, wrap the call to the old navigator.getUserMedia with a Promise\n\n\n          return new Promise(function (resolve, reject) {\n            getUserMedia.call(navigator, constraints, resolve, reject);\n          });\n        }; // Older browsers might not implement mediaDevices at all, so we set an empty object first\n\n\n        if (navigator.mediaDevices === undefined) {\n          navigator.mediaDevices = {};\n        } // Some browsers partially implement mediaDevices. We can't just assign an object\n        // with getUserMedia as it would overwrite existing properties.\n        // Here, we will just add the getUserMedia property if it's missing.\n\n\n        if (navigator.mediaDevices.getUserMedia === undefined) {\n          navigator.mediaDevices.getUserMedia = promisifiedOldGUM;\n        }\n      }\n      /**\n       * @author j_bleach 2018/8/19\n       * @describe 验证函数，如果存在即执行\n       * @param fn: function 被验证函数\n       * @param e: object 事件对象 event object\n       */\n\n    }, {\n      key: \"checkAndExecFn\",\n      value: function checkAndExecFn(fn, e) {\n        typeof fn === \"function\" && fn(e);\n      }\n      /**\n       * @author j_bleach 2022/04/17\n       * @describe 兼容safari\n       * @returns mimeType\n       */\n\n    }, {\n      key: \"mediaSupported\",\n      value: function mediaSupported() {\n        // safari used to not support this\n        // ...even if it supported media recorder\n        if (!MediaRecorder.isTypeSupported) {\n          return \"audio/mp4\";\n        } else if (MediaRecorder.isTypeSupported(\"audio/webm\")) {\n          return \"audio/webm\";\n        } else {\n          return \"audio/mp4\";\n        }\n      }\n    }]);\n\n    return MediaRecorderClass;\n  }(Target);\n};\n\nexport default MediaRecorderFn;","map":{"version":3,"mappings":"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","names":["convertWav","WebWorker","MediaRecorderFn","Target","constraints","audio","mp3Worker","Worker","_inherits","props","_classCallCheck","_this","startAudio","recorder","mediaRecorder","state","navigator","mediaDevices","getUserMedia","then","stream","recordAudio","catch","err","MediaRecorderClass","checkAndExecFn","errorCallback","resumeAudio","pauseAudio","pause","onpause","pauseCallback","audioCtx","suspend","stopAudio","audioType","audioOptions","includes","stop","onstop","audioStream2Blob","stopCallback","audioChunk","initCanvas","compatibility","window","AudioContext","webkitAudioContext","analyser","createAnalyser","_createClass","key","value","type","cb","wavBlob","chunk","audioWav","fr","FileReader","readAsArrayBuffer","Blob","frOnload","e","buffer","target","result","_this2","decodeAudioData","data","DataView","onload","audioMp3","wavBuf","postMessage","cmd","config","bitRate","rawInput","onmessage","mp3Blob","buf","mediaSupported","audioBitsPerSecond","timeslice","mimeType","MediaRecorder","ondataavailable","event","_this3","onRecordCallback","push","resume","start","onstart","startCallback","onresume","initAudioAnalyser","onerror","renderCurve","source","createMediaStreamSource","connect","promisifiedOldGUM","webkitGetUserMedia","mozGetUserMedia","_this4","Promise","reject","Error","resolve","call","undefined","fn","isTypeSupported"],"sources":["/Users/le-taoli/emotiondetecttemp/front/node_modules/react-audio-analyser/src/component/AudioAnalyser/MediaRecorder.js"],"sourcesContent":["/**\n * @author j_bleach 2018/8/18\n * @describe 媒体记录（包含开始，暂停，停止等媒体流及回调操作）\n * @param Target 被装饰类（AudioAnalyser）\n */\nimport convertWav from \"./audioConvertWav\";\nimport WebWorker from \"./mp3worker.js\";\n\nconst MediaRecorderFn = (Target) => {\n  const constraints = { audio: true };\n  const mp3Worker = new Worker(WebWorker);\n  return class MediaRecorderClass extends Target {\n    constructor(props) {\n      super(props);\n      MediaRecorderClass.compatibility();\n      this.audioChunk = []; // 音频信息存储对象\n      this.mediaRecorder = null; // 媒体记录对象\n      this.audioCtx = new (window.AudioContext || window.webkitAudioContext)(); // 音频上下文\n      this.analyser = this.audioCtx.createAnalyser();\n    }\n\n    /**\n     * @author j_bleach 2018/08/02 17:06\n     * @describe 浏览器navigator.mediaDevices兼容性处理\n     */\n    static compatibility() {\n      const promisifiedOldGUM = (constraints) => {\n        // First get ahold of getUserMedia, if present\n        const getUserMedia =\n          navigator.getUserMedia ||\n          navigator.webkitGetUserMedia ||\n          navigator.mozGetUserMedia;\n\n        // Some browsers just don't implement it - return a rejected promise with an error\n        // to keep a consistent interface\n        if (!getUserMedia) {\n          MediaRecorderClass.checkAndExecFn(\n            this.props ? this.props.errorCallback : null\n          );\n          return Promise.reject(\n            new Error(\"getUserMedia is not implemented in this browser\")\n          );\n        }\n        // Otherwise, wrap the call to the old navigator.getUserMedia with a Promise\n        return new Promise(function (resolve, reject) {\n          getUserMedia.call(navigator, constraints, resolve, reject);\n        });\n      };\n\n      // Older browsers might not implement mediaDevices at all, so we set an empty object first\n      if (navigator.mediaDevices === undefined) {\n        navigator.mediaDevices = {};\n      }\n\n      // Some browsers partially implement mediaDevices. We can't just assign an object\n      // with getUserMedia as it would overwrite existing properties.\n      // Here, we will just add the getUserMedia property if it's missing.\n      if (navigator.mediaDevices.getUserMedia === undefined) {\n        navigator.mediaDevices.getUserMedia = promisifiedOldGUM;\n      }\n    }\n\n    /**\n     * @author j_bleach 2018/8/19\n     * @describe 验证函数，如果存在即执行\n     * @param fn: function 被验证函数\n     * @param e: object 事件对象 event object\n     */\n    static checkAndExecFn(fn, e) {\n      typeof fn === \"function\" && fn(e);\n    }\n\n    /**\n     * @author j_bleach 2022/04/17\n     * @describe 兼容safari\n     * @returns mimeType\n     */\n    static mediaSupported() {\n      // safari used to not support this\n      // ...even if it supported media recorder\n      if (!MediaRecorder.isTypeSupported) {\n        return \"audio/mp4\";\n      } else if (MediaRecorder.isTypeSupported(\"audio/webm\")) {\n        return \"audio/webm\";\n      } else {\n        return \"audio/mp4\";\n      }\n    }\n\n    /**\n     * @author j_bleach 2018/8/19\n     * @describe 音频流转blob对象\n     * @param type: string 音频的mime-type\n     * @param cb: function 录音停止回调\n     */\n    audioStream2Blob(type, audioOptions, cb) {\n      let wavBlob = null;\n      const chunk = this.audioChunk;\n      const audioWav = () => {\n        let fr = new FileReader();\n        fr.readAsArrayBuffer(new Blob(chunk, { type }));\n        let frOnload = (e) => {\n          const buffer = e.target.result;\n          this.audioCtx.decodeAudioData(buffer).then((data) => {\n            wavBlob = new Blob([new DataView(convertWav(data, audioOptions))], {\n              type: \"audio/wav\",\n            });\n            MediaRecorderClass.checkAndExecFn(cb, wavBlob);\n          });\n        };\n        fr.onload = frOnload;\n      };\n      const audioMp3 = () => {\n        let fr = new FileReader();\n        fr.readAsArrayBuffer(new Blob(chunk, { type: \"audio/wav\" }));\n        let frOnload = (e) => {\n          const buffer = e.target.result;\n          this.audioCtx.decodeAudioData(buffer).then((data) => {\n            const wavBuf = convertWav(data, audioOptions);\n            mp3Worker.postMessage({\n              cmd: \"init\",\n              config: { bitRate: 128 },\n            });\n            mp3Worker.postMessage({ cmd: \"encode\", rawInput: wavBuf });\n            mp3Worker.postMessage({ cmd: \"finish\" });\n\n            mp3Worker.onmessage = (e) => {\n              if (e.data.cmd == \"end\") {\n                const mp3Blob = new Blob(e.data.buf, { type });\n                MediaRecorderClass.checkAndExecFn(cb, mp3Blob);\n              }\n            };\n          });\n        };\n        fr.onload = frOnload;\n      };\n      switch (type) {\n        case \"audio/webm\":\n        case \"audio/mp4\":\n          MediaRecorderClass.checkAndExecFn(\n            cb,\n            new Blob(chunk, { type: MediaRecorderClass.mediaSupported() })\n          );\n          break;\n        case \"audio/wav\":\n          audioWav();\n          break;\n        case \"audio/mp3\":\n          audioMp3();\n          break;\n        default:\n          return void 0;\n      }\n    }\n\n    /**\n     * @author j_bleach 2018/8/18\n     * @describe 开始录音\n     */\n    startAudio = () => {\n      const recorder = this.mediaRecorder;\n      if (!recorder || (recorder && recorder.state === \"inactive\")) {\n        navigator.mediaDevices\n          .getUserMedia(constraints)\n          .then((stream) => {\n            this.recordAudio(stream);\n          })\n          .catch((err) => {\n            MediaRecorderClass.checkAndExecFn(this.props.errorCallback, err);\n            // throw new Error(\"getUserMedia failed:\", err);\n          });\n        return false;\n      }\n      if (recorder && recorder.state === \"paused\") {\n        this.resumeAudio();\n      }\n    };\n    /**\n     * @author j_bleach 2018/8/19\n     * @describe 暂停录音\n     */\n    pauseAudio = () => {\n      const recorder = this.mediaRecorder;\n      if (recorder && recorder.state === \"recording\") {\n        recorder.pause();\n        recorder.onpause = () => {\n          MediaRecorderClass.checkAndExecFn(this.props.pauseCallback);\n        };\n        this.audioCtx.suspend();\n      }\n    };\n    /**\n     * @author j_bleach 2018/8/18\n     * @describe 停止录音\n     */\n    stopAudio = () => {\n      const { audioType, audioOptions } = this.props;\n      const recorder = this.mediaRecorder;\n      if (recorder && [\"recording\", \"paused\"].includes(recorder.state)) {\n        recorder.stop();\n        recorder.onstop = () => {\n          this.audioStream2Blob(\n            audioType,\n            audioOptions,\n            this.props.stopCallback\n          );\n          this.audioChunk = []; // 结束后，清空音频存储\n        };\n        this.audioCtx.suspend();\n        this.initCanvas();\n      }\n    };\n\n    /**\n     * @author j_bleach 2018/8/18\n     * @describe mediaRecorder音频记录\n     * @param stream: binary data 音频流\n     */\n    recordAudio(stream) {\n      const { audioBitsPerSecond, timeslice } = this.props;\n      const mimeType = MediaRecorderClass.mediaSupported();\n      this.mediaRecorder = new MediaRecorder(stream, {\n        audioBitsPerSecond,\n        mimeType,\n      });\n      this.mediaRecorder.ondataavailable = (event) => {\n        MediaRecorderClass.checkAndExecFn(\n          this.props.onRecordCallback,\n          event.data\n        );\n        this.audioChunk.push(event.data);\n      };\n      this.audioCtx.resume();\n      this.mediaRecorder.start(timeslice);\n      this.mediaRecorder.onstart = (e) => {\n        MediaRecorderClass.checkAndExecFn(this.props.startCallback, e);\n      };\n      this.mediaRecorder.onresume = (e) => {\n        this.initAudioAnalyser(stream);\n        MediaRecorderClass.checkAndExecFn(this.props.startCallback, e);\n      };\n      this.mediaRecorder.onerror = (e) => {\n        MediaRecorderClass.checkAndExecFn(this.props.errorCallback, e);\n      };\n      this.initAudioAnalyser(stream);\n      this.renderCurve();\n    }\n\n    /**\n     * @author j_bleach 2019/10/31\n     * @describe 重置音频上下文（解决谷歌浏览器 音频数组链接断开问题）\n     */\n\n    initAudioAnalyser(stream) {\n      this.analyser = this.audioCtx.createAnalyser();\n      const source = this.audioCtx.createMediaStreamSource(stream);\n      source.connect(this.analyser);\n    }\n\n    /**\n     * @author j_bleach 2018/8/19\n     * @describe 恢复录音\n     */\n    resumeAudio() {\n      this.audioCtx.resume();\n      this.mediaRecorder.resume();\n    }\n  };\n};\nexport default MediaRecorderFn;\n"]},"metadata":{},"sourceType":"module"}