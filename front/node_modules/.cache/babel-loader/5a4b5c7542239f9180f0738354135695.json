{"ast":null,"code":"/**\n * Created by j_bleach on 2018/8/25.\n */\nfunction audioBufferToWav(buffer) {\n  var opt = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var numChannels = buffer.numberOfChannels;\n  var sampleRate = opt.sampleRate || buffer.sampleRate;\n  var format = opt.float32 ? 3 : 1;\n  var bitDepth = format === 3 ? 32 : 16;\n  var result = void 0;\n\n  if (numChannels === 2) {\n    result = interleave(buffer.getChannelData(0), buffer.getChannelData(1));\n  } else {\n    result = buffer.getChannelData(0);\n  }\n\n  return encodeWAV(result, format, sampleRate, numChannels, bitDepth);\n}\n\nfunction encodeWAV(samples, format, sampleRate, numChannels, bitDepth) {\n  var bytesPerSample = bitDepth / 8;\n  var blockAlign = numChannels * bytesPerSample;\n  var buffer = new ArrayBuffer(44 + samples.length * bytesPerSample);\n  var view = new DataView(buffer);\n  /* RIFF identifier */\n\n  writeString(view, 0, \"RIFF\");\n  /* RIFF chunk length */\n\n  view.setUint32(4, 36 + samples.length * bytesPerSample, true);\n  /* RIFF type */\n\n  writeString(view, 8, \"WAVE\");\n  /* format chunk identifier */\n\n  writeString(view, 12, \"fmt \");\n  /* format chunk length */\n\n  view.setUint32(16, 16, true);\n  /* sample format (raw) */\n\n  view.setUint16(20, format, true);\n  /* channel count */\n\n  view.setUint16(22, numChannels, true);\n  /* sample rate */\n\n  view.setUint32(24, sampleRate, true);\n  /* byte rate (sample rate * block align) */\n\n  view.setUint32(28, sampleRate * blockAlign, true);\n  /* block align (channel count * bytes per sample) */\n\n  view.setUint16(32, blockAlign, true);\n  /* bits per sample */\n\n  view.setUint16(34, bitDepth, true);\n  /* data chunk identifier */\n\n  writeString(view, 36, \"data\");\n  /* data chunk length */\n\n  view.setUint32(40, samples.length * bytesPerSample, true);\n\n  if (format === 1) {\n    // Raw PCM\n    floatTo16BitPCM(view, 44, samples);\n  } else {\n    writeFloat32(view, 44, samples);\n  }\n\n  return buffer;\n}\n\nfunction interleave(inputL, inputR) {\n  var length = inputL.length + inputR.length;\n  var result = new Float32Array(length);\n  var index = 0;\n  var inputIndex = 0;\n\n  while (index < length) {\n    result[index++] = inputL[inputIndex];\n    result[index++] = inputR[inputIndex];\n    inputIndex++;\n  }\n\n  return result;\n}\n\nfunction writeFloat32(output, offset, input) {\n  for (var i = 0; i < input.length; i++, offset += 4) {\n    output.setFloat32(offset, input[i], true);\n  }\n}\n\nfunction floatTo16BitPCM(output, offset, input) {\n  for (var i = 0; i < input.length; i++, offset += 2) {\n    var s = Math.max(-1, Math.min(1, input[i]));\n    output.setInt16(offset, s < 0 ? s * 0x8000 : s * 0x7FFF, true);\n  }\n}\n\nfunction writeString(view, offset, string) {\n  for (var i = 0; i < string.length; i++) {\n    view.setUint8(offset + i, string.charCodeAt(i));\n  }\n}\n\nexport default audioBufferToWav;","map":{"version":3,"mappings":"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","names":["audioBufferToWav","buffer","opt","numChannels","numberOfChannels","sampleRate","format","float32","bitDepth","result","interleave","getChannelData","encodeWAV","samples","bytesPerSample","blockAlign","ArrayBuffer","length","view","DataView","writeString","setUint32","setUint16","floatTo16BitPCM","writeFloat32","inputL","inputR","Float32Array","index","inputIndex","output","offset","input","i","setFloat32","s","Math","max","min","setInt16","string","setUint8","charCodeAt"],"sources":["/Users/le-taoli/emotiondetecttemp/front/emotion-detector/node_modules/react-audio-analyser/src/component/AudioAnalyser/audioConvertWav.js"],"sourcesContent":["/**\n * Created by j_bleach on 2018/8/25.\n */\nfunction audioBufferToWav(buffer, opt = {}) {\n    let numChannels = buffer.numberOfChannels\n    let sampleRate = opt.sampleRate || buffer.sampleRate\n    let format = opt.float32 ? 3 : 1\n    let bitDepth = format === 3 ? 32 : 16\n    let result\n    if (numChannels === 2) {\n        result = interleave(buffer.getChannelData(0), buffer.getChannelData(1))\n    } else {\n        result = buffer.getChannelData(0)\n    }\n\n    return encodeWAV(result, format, sampleRate, numChannels, bitDepth)\n}\n\nfunction encodeWAV(samples, format, sampleRate, numChannels, bitDepth) {\n    let bytesPerSample = bitDepth / 8\n    let blockAlign = numChannels * bytesPerSample\n\n    let buffer = new ArrayBuffer(44 + samples.length * bytesPerSample)\n    let view = new DataView(buffer)\n\n    /* RIFF identifier */\n    writeString(view, 0, \"RIFF\")\n    /* RIFF chunk length */\n    view.setUint32(4, 36 + samples.length * bytesPerSample, true)\n    /* RIFF type */\n    writeString(view, 8, \"WAVE\")\n    /* format chunk identifier */\n    writeString(view, 12, \"fmt \")\n    /* format chunk length */\n    view.setUint32(16, 16, true)\n    /* sample format (raw) */\n    view.setUint16(20, format, true)\n    /* channel count */\n    view.setUint16(22, numChannels, true)\n    /* sample rate */\n    view.setUint32(24, sampleRate, true)\n    /* byte rate (sample rate * block align) */\n    view.setUint32(28, sampleRate * blockAlign, true)\n    /* block align (channel count * bytes per sample) */\n    view.setUint16(32, blockAlign, true)\n    /* bits per sample */\n    view.setUint16(34, bitDepth, true)\n    /* data chunk identifier */\n    writeString(view, 36, \"data\")\n    /* data chunk length */\n    view.setUint32(40, samples.length * bytesPerSample, true)\n    if (format === 1) { // Raw PCM\n        floatTo16BitPCM(view, 44, samples)\n    } else {\n        writeFloat32(view, 44, samples)\n    }\n\n    return buffer\n}\n\nfunction interleave(inputL, inputR) {\n    let length = inputL.length + inputR.length\n    let result = new Float32Array(length)\n\n    let index = 0\n    let inputIndex = 0\n\n    while (index < length) {\n        result[index++] = inputL[inputIndex]\n        result[index++] = inputR[inputIndex]\n        inputIndex++\n    }\n    return result\n}\n\nfunction writeFloat32(output, offset, input) {\n    for (let i = 0; i < input.length; i++, offset += 4) {\n        output.setFloat32(offset, input[i], true)\n    }\n}\n\nfunction floatTo16BitPCM(output, offset, input) {\n    for (let i = 0; i < input.length; i++, offset += 2) {\n        let s = Math.max(-1, Math.min(1, input[i]))\n        output.setInt16(offset, s < 0 ? s * 0x8000 : s * 0x7FFF, true)\n    }\n}\n\nfunction writeString(view, offset, string) {\n    for (let i = 0; i < string.length; i++) {\n        view.setUint8(offset + i, string.charCodeAt(i))\n    }\n}\n\nexport default audioBufferToWav"]},"metadata":{},"sourceType":"module"}